\documentclass[a4paper,oneside]{report}
\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{fullpage}
\usepackage{listings}
%\usepackage{fancyvrb}
\usepackage{float}
\usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=black]{hyperref}
\usepackage{gmverb}
\usepackage{graphicx}
\usepackage{color}
\lstset{ %
language=Python,
basicstyle=\footnotesize,
numbers=left,
numberstyle=\footnotesize,
stepnumber=1,
numbersep=5pt,
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=single,
tabsize=2,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
escapeinside={\%}
}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\title{Compiladores e Intérpretes\\Manual del Desarrollador}

\author{Diego Marcovecchio (LU: 83815)\and Leonardo Molas (LU: 82498)}

\date{6 de Diciembre de 2010}
	
\begin{document}
	
\maketitle

\tableofcontents

\chapter*{Introducción} 

\addcontentsline{toc}{chapter}{Introducción}

Éste es el Manual del Desarrollador del compilador \textsc{pyComp}, donde se explicará su desarrollo a partir de sus diferentes etapas. En los capítulos que siguen se detallarán las etapas por las que pasó el desarrollo del compilador: el análisis léxico, la gramática y su pasaje a LL(1), el análisis sintáctico, semántico, y la traducción a código intermedio especificado en un EdT.

El compilador fue desarrollado íntegramente en la versión 2.7 del lenguaje \textsc{Python}. La elección fue realizada debido a muchas características del lenguaje; fue particularmente aprovechado el poderoso manejo de strings, archivos, y expresiones regulares; también se utilizó herencia múltiple, y se aprovechó el tipado dinámico en reiteradas ocasiones. Además, dado que \textsc{Python} hace hincapié en una sintaxis muy limpia, el código escrito resulta muy facilmente legible; por último, es especialmente valorado por los miembros de la comisión al tratarse de una herramienta con código abierto y licencia GPL.

Toda la evolución de cada una de las etapas compilador, los informes y las pruebas realizadas fue gestionada utilizando el sistema de control de versiones {\bf git}, y puede ser encontrada en los repositorios del servidor \texttt{github} en la dirección: \url{https://github.com/diegomarcov/Compilador-MiniPascal}

\chapter{Analizador léxico}

El Analizador Léxico del compilador se encuentra en la carpeta (paquete) \texttt{lexer}, y cuenta con dos módulos: \texttt{myshlex.py}, y \texttt{lexan.py}. Veremos a continuación cada una de las secciones reelevantes del analizador.

\section{Alfabeto de entrada}

Los \textit{tokens} del analizador están compuestos por letras, dígitos, y símbolos especiales; dentro de los símbolos especiales consideramos, además, las palabras reservadas del lenguaje Mini-Pascal. Cualquier caracter leído que no forme parte de los símbolos mostrados produce un \texttt{Lexical error}, que aborta inmediatamente la compilación.

\begin{verbatim}
<letter>::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z

<digit>::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<special symbol> ::=  + | - | * | = | <> | < | > | <= | >= | ( | ) | [ | ] | { | } | := | . | , | ; | : | div | or | and | not | if | then | else | while | do | begin | end | const | var | type | array | function | procedure | program
\end{verbatim}

\section{Diseño general}

Detallaremos a continuación la arquitectura general del analizador léxico, describiendo brevemente cada una de las clases que lo componen. 

\subsection{Palabras reservadas}
El Analizador Léxico reconoce las palabras especificadas en la tabla \ref{tab:palabras} como palabras reservadas. Esto significa, por un lado, que si dichas palabras son utilizadas en cualquier contexto que no sea el esperado, se producirá un error sintáctico; por otro lado, un identificador nunca podrá ser una de las palabras reservadas.

\begin{table}[htbc]
\centering
\begin{tabular}{|c|}
\hline
\textbf{Palabras reservadas} \\  \hline
\ttfamily
program \\ 
\texttt{type} \\ 
\texttt{const} \\ 
\texttt{var} \\ 
\texttt{array} \\ 
\texttt{of} \\ 
\texttt{function} \\ 
\texttt{procedure} \\ 
\texttt{begin} \\ 
\texttt{end} \\ 
\texttt{while} \\ 
\texttt{do} \\ 
\texttt{if} \\ 
\texttt{then} \\ 
\texttt{else} \\ 
\texttt{div} \\ 
\texttt{not} \\ 
\texttt{or} \\ 
\texttt{and} \\ 
\hline
\end{tabular}
\label{tab:palabras}
\caption{Palabras reservadas}
\end{table}


\subsection{LexAn}

La clase {\bf LexAn}, cuyo código fuente puede ser encontrado en el archivo \texttt{lexan.py} de la carpeta \texttt{/src/lexer/}, procesa los lexemas provistos por {\bf shlex} para transformarlos en tokens, que finalmente serán utilizados por el analizador sintáctico (como se detallará en el capítulo correspondiente). Para reconocer los lexemas, la clase cuenta con dos pilares: una estructura de diccionario de Python (un arreglo asociativo), y el reconocimiento de expresiones regulares utilizando la librería {\bf re}. La clase permite además saber qué lexema y número de línea del archivo fuente está siendo analizando.

Los operadores y las palabras reservadas (que pueden ser encontradas en la tabla \ref{tab:palabras}) que cuentan con un token propio son cargadas inicialmente en el diccionario. Al momento de analizar un lexema, se realiza un checkeo para ver si dicho lexema es uno de los \textit{id} del diccionario. En ese caso, se retorna inmediatamente el token asociado. En caso contrario, se compara el lexema con las expresiones regulares de identificador, número, y caracter (devolviendo el respectivo token en caso de match). Si ninguna de estas opciones tiene éxito, se dispara la excepción \textit{LexError}, indicando que el lexema no pudo ser reconocido.

Por último, si al intentar obtener el siguiente lexema de {\bf shlex} se captura la excepción \textit{EOFError}, dicha excepción es propagada, informando que un comentario se mantuvo abierto hasta el final del archivo.

\subsection{shlex}

Esta clase se encuentra en el archivo \texttt{myshlex.py}, y contiene el código de la librería {\bf shlex} de Python (creada originalmente para procesar scripts de consola) modificado para que ignore los comentarios del archivo fuente a medida que lee los caracteres, y adaptado para los separadores y el alfabeto propio de Mini-Pascal. El procedimiento más importante de la clase devuelve un lexema del archivo fuente, y permite además saber en qué línea se encuentra dicho lexema.

Además de las modificaciones mencionadas, se agregó la excepción \textit{EOFError}, que es lanzada cuando se encuentra el caracter de fin de archivo cuando todavía se estaba procesando un comentario. Esta excepción es aprovechada por LexAn para saber cuándo un comentario multilínea se mantiene abierto de manera errónea.

\section{Tokens}
El Analizador Léxico reconoce todos los tokens especificados en la tabla \ref{tab:tokens} cuando encuentra una expresión regular que coincide con las mostradas. Los tokens son utilizados posteriormente por el analizador sintáctico.

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Token}			& \textbf{Expresión Regular} \\ \hline
Identifier 					& {\ttfamily [a-zA-Z][a-zA-Z0-9]*} \\ \hline
Number							& {\ttfamily [0-9]+} \\ \hline
Char								& {\ttfamily '[a-zA-Z0-9]'} \\ \hline
Less\_Op						& {\ttfamily <\ }  \\ \hline %si se le sacan el backslash espacio se re pincha. es una mierda latex
Greater\_Op					& {\ttfamily >\ } \\ \hline
Greater\_Equal\_Op	& {\ttfamily >=} \\ \hline
Less\_Equal\_Op			& {\ttfamily <=} \\ \hline
Not\_Equal\_Op			& {\ttfamily <>\ } \\ \hline
Add\_Op		 					& {\ttfamily +}\\ \hline
Minus\_Op 					& {\ttfamily -}\\ \hline
Multiply\_Op				& {\ttfamily *}\\ \hline
Div\_Op							& {\ttfamily [dD][iI][vV]}\\\hline
Not\_LogOp 					& {\ttfamily [nN][oO][tT]} \\ \hline
Or\_LogOp 					& {\ttfamily [oO][rR]} \\ \hline
And\_LogOp 					& {\ttfamily [aA][nN][dD]} \\ \hline
Equal 							& {\ttfamily =} \\ \hline
Type\_Declaration 	& {\ttfamily :} \\ \hline
Assignment 					& {\ttfamily :=} \\ \hline
Comma 							& {\ttfamily ,} \\ \hline
Semicolon 					& {\ttfamily ;} \\ \hline
End\_Program			 	& {\ttfamily .} \\ \hline
Subrange\_Separator & {\ttfamily ..} \\ \hline 
Open\_Parenthesis 	& {\ttfamily (} \\ \hline
Close\_Parenthesis 	& {\ttfamily )} \\ \hline
Open\_Bracket 			& {\ttfamily [} \\ \hline
Close\_Bracket 			& {\ttfamily ]} \\ \hline
Program 						& {\ttfamily [pP][rR][oO][gG][rR][aA][mM]} \\ \hline
Type 								& {\ttfamily [tT][yY][pP][eE]} \\ \hline
Const 							& {\ttfamily [cC][oO][nN][sS][tT]} \\ \hline
Var 								& {\ttfamily [vV][aA][rR]} \\ \hline
Function 						& {\ttfamily [fF][uU][nN][cC][tT][iI][oO][nN]} \\ \hline
Procedure 					& {\ttfamily [pP][rR][oO][cC][eE][dD][uU][rR][eE]} \\ \hline
Array 							& {\ttfamily [aA][rR][rR][aA][yY]} \\ \hline
Of 									& {\ttfamily [oO][fF]} \\ \hline
Begin 							& {\ttfamily [bB][eE][gG][iI][nN]} \\ \hline
End 								& {\ttfamily [eE][nN][dD]} \\ \hline
While 							& {\ttfamily [wW][hH][iI][lL][eE]} \\ \hline
Do 									& {\ttfamily [dD][oO]} \\ \hline
If 									& {\ttfamily [iI][fF]} \\ \hline
Then 								& {\ttfamily [tT][hH][eE][nN]} \\ \hline
Else 								& {\ttfamily [eE][lL][sS][eE]} \\ \hline
EOF 								&  \\ \hline
\end{tabular}
\label{tab:tokens}
\caption{Tokens}
\end{table}


\section{Errores detectados}
El analizador léxico es, además, el encargado de detectar algunos errores particulares. Entre éstos se encuentran:

\begin{itemize}
	\item Caracter no reconocido: si se intenta ingresar un caracter que no pertenece al alfabeto, como ``@'', se producirá un error.
	\item Comentarios abiertos: si el programa fuente tiene un comentario sin cerrar cuando termina el archivo, se informa el error.
	\item Números mal formados: si se intenta ingresar un número como 38a7, se informará el error.
	\item Lexema no reconocido: cualquier lexema que no corresponda con ninguna expresión regular de las mencionadas anteriormente, disparará una excepción. Cabe aclarar que este control no es realizado dentro de los comentarios, por lo que un bloque de comentarios puede tener cualquier conjunto de caracteres sin producir errores.
\end{itemize}

Las excepciones que disparará el analizador léxico serán las \texttt{LexError}. Los mensajes de error mostrarán el número de línea, con el lexema que generó el error, cuando corresponda.

\chapter{Gramática}

En esta sección se detallará la gramática utilizada, sus transformaciones, y consideraciones.

\section{EBNF}

En el Manual del Usuario se encuentra desglosada e íntegramente explicada la primera versión de la gramática, adaptada de la escrita por Wirth, y modificada para satisfacer los requerimientos de nuestra versión del lenguaje (Mini-Pascal). Por conveniencia, esta primera versión, en formato EBNF, será replicada aquí de manera completa.

\begin{verbatim}
<program> ::= <program heading> <block>.

<program heading> ::= program <identifier>;

<block> ::= <constant definition part><type definition part><variable declaration part><procedure and function declaration part><statement part>

<constant definition part> ::= <empty> | const <constant definition>{;<constant definition>};

<constant definition> ::= <identifier>=<constant>

<identifier> ::= <letter>{<letter or digit>}

<letter or digit> ::= <letter> | <digit>

<letter> ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<constant> ::= <unsigned number> | <sign><unsigned number> | <constant identifier> | <sign><constant identifier> | <char>

<unsigned number> ::= <unsigned integer>

<unsigned integer> ::= <digit sequence>

<digit sequence> ::= <digit>{<digit>}

<sign> ::= + | -

<constant identifier> ::= <identifier>

<type definition part> ::= <empty> | type <type definition>{;<type definition>};

<type definition> ::= <identifier>=<type>

<type> ::= <simple type> | <structured type>

<simple type> ::= <subrange type> | <type identifier>

<subrange type> ::= <constant>..<constant>

<type identifier> ::= <identifier>

<structured type> ::= <unpacked structured type>

<unpacked structured type> ::= <array type>

<array type> ::= array[<index type>] of <component type>

<index type> ::= <simple type>

<component type> ::= <simple type>

<variable definition part> : := <empty> | var<variable declaration>{;<variable declaration>};

<variable declaration> ::= <identifier>{,<identifier>} : <type>

<procedure and function declaration part> ::= {<procedure or function declaration part>;}

<procedure or function declaration part> ::= <procedure declaration> | <function declaration>

<procedure declaration> ::= <procedure heading><block>

<procedure heading> ::= procedure <identifier>; | procedure <identifier>(<formal parameter section>{;<formal parameter section>});

<formal parameter section> ::= <parameter group> | var <parameter group>

<parameter group> ::= <identifier>{,<identifier>}:<type identifier>

<function declaration> ::= <function heading><block>

<function heading> ::= function<identifier>:<result type>; | <function identifier>(<formal parameter section>{;<formal parameter section>}):<result type>;

<result type> ::= <type identifier>

<statement part> ::= <compound statement>

<compound statement> ::= begin <statement>{;<statement>} end

<statement> ::= <unlabelled statement>

<unlabelled statement> ::= <simple statement> | <structured statement>

<simple statement> ::= <assignment statement> | <procedure statement> | <empty statement>

<assignment statement> ::= <variable>:=<expression> | <function identifier>:=<expression>

<variable> ::= <entire variable> | <component variable>

<entire variable> ::= <variable identifier>

<variable identifier> ::= <identifier>

<component variable> ::= <indexed variable>

<indexed variable> ::= <array variable>[<expression>]

<array variable> ::= <entire variable>

<expression> ::= <simple expression> | <simple expression><relational operator><simple expression>

<simple expression> ::= <term> | <simple expression><adding operator><term> | <sign><term>

<term>::= <factor> | <term><multiplying operator><factor>

<factor> ::= <variable> | <unsigned constant> | <function designator> | (<expression>) | not <factor> | <char>

<char> ::= '<letter>' | '<digit>'

<unsigned constant> ::= <unsigned number> | <constant identifier>

<function designator> ::= <function identifier> | <function identifier>(<actual parameter>{,<actual parameter>})

<function identifier> ::= <identifier>

<actual parameter> ::= <expression> | <variable>

<multiplying operator> ::= * | div | and

<adding operator> ::= + | - | or

<relational operator> ::= = | <> | < | <= | >= | >

<procedure statement> ::= <procedure identifier> | <procedure identifier>(<actual parameter>{,<actual parameter>})

<procedure identifier> ::= <identifier>

<empty statement> ::= <empty>

<structured statement> ::= <compound statement> | <conditional statement> | <repetitive statement>

<conditional statement> ::= <if statement>

<if statement> ::= if <expression> then <statement> | if <expression> then <statement> else <statement>

<repetitive statement> ::= <while statement>

<while statement> ::= while <expression> do <statement>
\end{verbatim}

\section{Gramática final}

Como siguiente paso en la adaptación de la gramática, se reemplazaron los terminales por los tokens que devuelve \textbf{LexAn}. Para esto, se adoptó la convención de dejar los no terminales en minúscula, mientras que los tokens (terminales) se encuentran en MAYÚSCULA. Luego, se eliminaron las extensiones propias de la notación EBNF.

Finalmente, para llegar a la gramática utilizada para implementar el analizador sintáctico, se realizaron los siguientes pasos:
\begin{enumerate}
	\item \textbf{Eliminar Ambiguedad}: Ésta tal vez sea la afirmación más peligrosa, ya que no se puede saber si una gramática es ambigua o no. De cualquier manera, se eliminaron todas las ambiguedades que se encontraron, salvo el caso del \verb|if-then-else|, del cual se hablará más adelante.
	\item \textbf{Eliminar Recursión a Izquierda}: Se utilizó el algoritmo explicado en \cite[pág. 212]{aho}.
	\item \textbf{Factorizar a Izquierda}: Se utilizó el algoritmo explicado en el mismo libro, en la página 214.
\end{enumerate}

Luego de esta serie de pasos, se llegó a la siguiente gramática:

\begin{verbatim}
<program> ::= <program_heading> <block> <END_PROGRAM> <EOF>

<program_heading> ::= <PROGRAM> <IDENTIFIER> <SEMI_COLON>

<block> ::= <constant_definition_part> <block_cons_rest> | <block_cons_rest>

<block_cons_rest> ::= <type_definition_part> <block_type_rest> | <block_type_rest>

<block_type_rest> ::= <variable_definition_part> <block_var_rest> | <block_var_rest>

<block_var_rest> ::= <procedure_and_function_declaration_part> <statement_part> | <statement_part>

<constant_definition_part> ::= <CONST> <constant_definition> <constant_definition_rest>

<constant_definition_rest> ::= <SEMI_COLON> <constant_definition_rest_rest>

<constant_definition_rest_rest> ::= <constant_definition> <constant_definition_rest> | <LAMBDA>

<constant_definition> ::= <IDENTIFIER> <EQUAL> <constant>

<constant> ::= <NUMBER> | <IDENTIFIER> | <CHAR> | <sign> <constant_rest>

<constant_rest> ::= <NUMBER> | <IDENTIFIER>

<sign> ::= <ADD_OP> | <MINUS_OP>

<type_definition_part> ::= <TYPE> <type_definition> <type_definition_rest>

<type_definition_rest> ::= <SEMI_COLON> <type_definition_rest_rest>

<type_definition_rest_rest> ::= <type_definition> <type_definition_rest> | <LAMBDA>

<type_definition> ::= <IDENTIFIER> <EQUAL> <type>

<type> ::= <simple_type> | <structured_type>

<simple_type> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> | <CHAR> <SUBRANGE_SEPARATOR> <constant> | <sign> <subrange_type_rest> | <IDENTIFIER> <simple_type_rest>

<simple_type_rest> ::= <SUBRANGE_SEPARATOR> <constant> | <LAMBDA>

<subrange_type_rest> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> | <IDENTIFIER> <SUBRANGE_SEPARATOR> <constant>

<structured_type> ::= <ARRAY> <OPEN_BRACKET> <simple_type> <CLOSE_BRACKET> <OF> <simple_type>

<variable_definition_part> ::= <VAR> <variable_declaration> <variable_declaration_part_rest>

<variable_declaration_part_rest> ::= <SEMI_COLON> <variable_declaration_rest_rest>

<variable_declaration_rest_rest> ::= <variable_declaration> <variable_declaration_part_rest> | <LAMBDA>

<variable_declaration> ::= <IDENTIFIER> <variable_declaration_rest>

<variable_declaration_rest> ::= <COMMA> <IDENTIFIER> <variable_declaration_rest> | <TYPE_DECLARATION> <type>

<procedure_and_function_declaration_part> ::= <procedure_or_function_declaration_part> <SEMI_COLON> <procedure_and_function_declaration_part> | <LAMBDA>

<procedure_or_function_declaration_part> ::= <procedure_declaration> | <function_declaration>

<procedure_declaration> ::= <procedure_heading> <block>

<procedure_heading> ::= <PROCEDURE> <IDENTIFIER> <procedure_heading_rest>

<procedure_heading_rest> ::= <SEMI_COLON> | <OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_rest>

<formal_parameter_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_rest> | <CLOSE_PARENTHESIS> <SEMI_COLON>

<formal_parameter_section> ::= <parameter_group> | <VAR> <parameter_group>

<parameter_group> ::= <IDENTIFIER> <parameter_group_rest>

<parameter_group_rest> ::= <COMMA> <IDENTIFIER> <parameter_group_rest> | <TYPE_DECLARATION> <IDENTIFIER>

<function_declaration> ::= <function_heading> <block>

<function_heading> ::= <FUNCTION> <IDENTIFIER> <function_heading_rest>

<function_heading_rest> ::= <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON> | <OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_function_rest>

<formal_parameter_function_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_function_rest> | <CLOSE_PARENTHESIS> <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON>

<statement_part> ::= <compound_statement>

<compound_statement> ::= <BEGIN> <statement> <statement_part_rest> <END>

<statement_part_rest> ::= <SEMI_COLON> <statement> <statement_part_rest> | <LAMBDA>

<statement> ::= <simple_statement> | <structured_statement>

<simple_statement> ::= <IDENTIFIER> <simple_statement_rest> | <LAMBDA>

<simple_statement_rest> ::= <ASSIGNMENT> <expression> | <OPEN_BRACKET> <expression> <CLOSE_BRACKET> <ASSIGNMENT> <expression> | <OPEN_PARENTHESIS> <actual_parameter> <actual_parameter_rest> | <LAMBDA>

<component_variable> ::= <IDENTIFIER> <OPEN_BRACKET> <expression> <CLOSE_BRACKET>

<expression> ::= <simple_expression> <expression_rest>

<expression_rest> ::= <relational_operator> <simple_expression> | <LAMBDA>

<simple_expression> ::= <term> <simple_expression_other> 

<simple_expression_other> ::= <adding_operator> <term> <simple_expression_other> | <LAMBDA>

<term> ::= <factor> <term_other>

<term_other> ::= <multiplying_operator> <factor> <term_other> | <LAMBDA>

<factor> ::= <IDENTIFIER> <factor_rest> | <NUMBER> | <OPEN_PARENTHESIS> <expression> <CLOSE_PARENTHESIS> | <NOT_LOGOP> <factor> | <CHAR> | <sign> <factor>

<factor_rest> ::= <OPEN_BRACKET> <expression> <CLOSE_BRACKET> | <OPEN_PARENTHESIS> <actual_parameter> <actual_parameter_rest> | <LAMBDA>

<actual_parameter> ::= <expression>

<actual_parameter_rest> ::= <COMMA> <actual_parameter> <actual_parameter_rest> | <CLOSE_PARENTHESIS>

<multiplying_operator> ::= <MULTIPLY_OP> | <DIV_OP> | <AND_LOGOP>

<adding_operator> ::= <ADD_OP> | <MINUS_OP> | <OR_LOGOP>

<relational_operator> ::= <LESS_OP> | <LESS_EQUAL_OP> | <GREATER_OP> | <GREATER_EQUAL_OP> | <NOT_EQUAL_OP> | <EQUAL>

<structured_statement> ::= <compound_statement> | <conditional_statement> | <repetitive_statement>

<conditional_statement> ::= <IF> <expression> <THEN> <statement> <conditional_statement_other>

<conditional_statement_other> ::= <ELSE> <statement> | <LAMBDA>

<repetitive_statement> ::= <WHILE> <expression> <DO> <statement>
\end{verbatim}

\section{¿Es LL(1)?}
La gramática pasó por todos los pasos especificados, en un intento de lograr una gramática para ser utilizada como base de la implementación de un Analizador Sintáctico Descendente Predictivo Recursivo. Cada regla tiene conjuntos disjuntos de la función \textsc{Primero} para cada producción, por lo que el analizador puede saber qué producción optar leyendo un único token. Por esto, se podría decir que la gramática obtenida es LL(1).

Sin embargo, como fue dicho en la sección anterior, la gramática contiene por lo menos una ambigüedad: la del \verb|if-then-else|. La cadena de tokens \verb|<IF> ... <THEN> <IF> ... <THEN> ... <ELSE> ...| (donde los puntos suspensivos representan un grupo de statements válidos) tiene dos árboles de derivación posibles.

La solución adoptada para resolver el conflicto es la de utilizar precedencia, donde el \verb|<ELSE>| quedará ligado al \verb|<IF> ... <THEN>| sin \verb|<ELSE>| más cercano. Ésta solución se lleva a cabo en la etapa de análisis semántico.

Se puede concluir, entonces, que la gramática no es LL(1), pero de cualquier manera sirve para implementar el Analizador Sintáctico.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Analizador Sintáctico}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Diseño General}
En esta sección se detallará la arquitectura del Analizador Sintáctico \textbf{SynAn}, describiendo la serie de archivos y clases que lo componen, así como las decisiones de diseño tomadas. 

\subsection{VortexWriter}
Se encuentra en \verb|utils.py|. Su única función es proveer un método \textit{write} que no hace nada (como escribir en \verb|/dev/null| en los sistemas GNU/Linux). En la sección siguiente se detallará su uso.


\subsection{SynAn}
El código de esta clase se encontraba en el archivo \verb|SynAn.py| en las versiones anteriores; dado que en la última entrega se mezcla el análisis sintáctico con las acciones semánticas, todo el proceso se encuentra en la clase principal del compilador, \texttt{pycomp.py}. Para su inicialización requiere el Analizador Léxico \textbf{LexAn}. Se le puede pasar un flag de debug y un archivo en el cual escribir la salida. Si el flag de debug es falso, se asigna la salida de debug a una clase que no escribe nada (VortexWriter). Esta decisión se tomó para no tener que realizar un \texttt{if} cada vez que se escriba un mensaje de debug, sino que directamente se escriba siempre, y dependiendo de la clase del objeto se mostrará en el archivo de salida o no. En caso de especificar el flag, todos los mensajes de debug serán mostrados en el archivo de salida. A su vez, si el archivo de salida no es especificado, se considerará por defecto como \textit{stdout}, por lo que la salida por defecto del compilador se realiza por pantalla.

El analizador contiene el método \verb|execute| que inicializa el proceso de análisis sintáctico, y devuelve el mensaje de éxito.

El resto de los procedimientos se mapean a los no-terminales de la gramática; su funcionamiento se basa en pedir tokens al analizador léxico, decidir que regla tomar, y luego llamar a los procedimientos correspondientes o pedir más tokens para checkear que sean los esperados.

En los casos en los que esto no sucede, se arroja una excepción.

\section{Errores detectados}

El analizador sintáctico arroja excepciones del tipo \verb|SynError|, declarada en el archivo \verb|utils.py|, que devuelve errores con el mayor grado de precisión posible, incluyendo las cadenas encontradas (que produjeron el error), lo que se esperaba encontrar, el número de línea y el nombre del archivo donde se encontró el error.

%%%%%%%%%%%%%%%%%%%%%ESQUEMA

\chapter{Esquema de Traducción}

Antes de comenzar con la implementación del analizador semántico se especificó un Esquema de Traducción como los estudiados durante el cuatrimestre para tener una buena representación de las acciones que el compilador debe realizar durante el análisis de los archivos fuente.

Cabe destacar que el Esquema de Traducción se presenta en \emph{pseudo-código}, y en él se detallan todos los controles que realiza el compilador durante el análisis, pero {\bf no} la generación de código intermedio. En su lugar, simplemente se indica textualmente qué debe hacer el código que se debe generar; ésta decisión se tomó para no ensuciar el Esquema de Traducción, puesto que el código MEPa fue generado en la última parte de la implementación del compilador.

\begin{lstlisting}[tabsize=4]
<program> ::= 	{
					stStack = newSymbolTableStack()
					
				} 
				<program_heading>
				{
					<block>.idPrograma = <program_heading>.id
					#inicializar el programa con INPP
				}
				<block> <END_PROGRAM> <EOF>
				{
					#escribe los procedimientos de read usados
					#finalizar el programa (PARA)
				}

<program_heading> ::= <PROGRAM> <IDENTIFIER>
					{
						<program_heading>.id = <IDENTIFIER>.lex
					}
					<SEMI_COLON>

<block> ::= { 
				stStack.pushNewSymbolTable() 
				if <block>.idPrograma != None:
					stStack.addNewID(<block>.idPrograma], Attr(tipo="program", type = Program()))
				if <block>.parameterList!= None:
					n = <block>.parameterList.tamanio # se calcula el tamaño de las variables, para conocer el offset de los parametros.
					
				if <block>.returnType!=None:
					addNewID("$" + <block>.idFuncion, Attr(clase = "return", tipo = <block>.returnType.tipo, pos = -(n+3)))
					
				i=0
				for x in <block>.parameterList:
					if x.referencia:
						clase = "reference"
					else:
						clase = "variable"
					addNewID(x.nombre, Attr(clase = clase, tipo = x.tipo, pos = -(n+3-i))
					if x.referencia:
						i+=1
					else:
			}
            <constant_definition_part> <block_cons_rest> 
			{
				stStack.pop()
			}
            | 
            { 
				stStack.pushNewSymbolTable() 
				if <block>.idPrograma != None:
					stStack[-1][<block>.idPrograma] = newAttr(tipo="program", type = Program())
					
				if <block>.parameterList!= None:
					n = <block>.parameterList.tamanio # se calcula el tamaño de las variables, para conocer el offset de los parametros.
					
				if <block>.returnType!=None:
					addNewID("$" + <block>.idFuncion, Attr(clase = "return", tipo = <block>.returnType.tipo, pos = -(n+3)))
					
				i=0
				for x in <block>.parameterList:
					if x.referencia:
						clase = "reference"
					else:
						clase = "variable"
					addNewID(x.nombre, Attr(clase = clase, tipo = x.tipo, pos = -(n+3-i))
					if x.referencia:
						i+=1
					else:
						i+=x.tipo.tamanio
			}
            <block_cons_rest>
			{
				stStack.pop()
			}

<block_cons_rest> ::= <type_definition_part> <block_type_rest> 
						{
							#libero memoria (<block_type_rest>.tamanioVariables)
						}
						| 
						<block_type_rest>
						{
							#libero memoria (<block_type_rest>.tamanioVariables)
						}

<block_type_rest> ::= <variable_definition_part> <block_var_rest> | <block_var_rest>

<block_var_rest> ::= 	{
							#poner el salto al principio de los statements
						}
						<procedure_and_function_declaration_part> 
						{
							#poner el label del principio de los statements
						}
						<statement_part> 
						| 
						<statement_part>

<constant_definition_part> ::= <CONST> <constant_definition> <constant_definition_rest>

<constant_definition_rest> ::= <SEMI_COLON> <constant_definition_rest_rest>

<constant_definition_rest_rest> ::= <constant_definition> <constant_definition_rest> | <LAMBDA>

<constant_definition> ::= <IDENTIFIER> <EQUAL> <constant> 
							{
                                # addNewID deberá tener un identificador, y un objeto;
                                # dicho objeto tendrá las propiedades: TIPO, VALOR, y un valor booleano que indica si es constante
								addNewID(<IDENTIFIER>.lex, <constant>.attr, clase = "constant")
							}

<constant> ::= 	<NUMBER>
				{
					if Entero.inBounds(int(<NUMBER>.lex)): #chequeo que no se vaya de los valores posibles
						<constant>.attr = newAttr(clase="constant", type=Entero(), value=<NUMBER>.lex)
				}
				|
				<IDENTIFIER>
				{
					val = getGlobalValue(<IDENTIFIER>.lex)
					if ((val != None)):
						if (val.clase=="constant"):
							<constant>.attr = copy(val) #copio el attr
						else:
							error("Invalid assignment: constant expected")

					else:
						error("Undeclared identifier " + <IDENTIFIER>.lex)
				}
				| 
				<CHAR> 
				{
                    <constant>.attr = newAttr(clase="constant", type=Char(), value=<CHAR>.lex)
				}
				| <sign> <constant_rest>
				{
					if !<constant_rest>.tipo.instancia(Entero):
						error("Can not apply "+<sign>.lex+" operator to "+<constant_rest>.tipo) #como redefino __str__ de todos los tipos puedo hacer cosas como esa
					else:
                        <constant_rest>.attr.value = <sign>.value * <constant_rest>.attr.value
                        <constant>.attr = <constant_rest>.attr
				}
				

<constant_rest> ::= <NUMBER> 
					{
						<constant_rest>.attr = newAttr(clase="constant", type=Entero(), value=<NUMBER>.lex)
					}
					|
					<IDENTIFIER>
					{
						val = getGlobalValue(<IDENTIFIER>.lex)
						if ((val != None)):
							if (val.clase=="constant"):
								<constant>.attr = copy(val) #copio el attr
							else:
								error(<IDENTIFIER>.lex + "is not a valid identifier")
						else:
							error("Undeclared identifier " + <IDENTIFIER>.lex)
					}

<sign> ::= <ADD_OP>
			{
				<sign>.value = 1
			}
			|
			<MINUS_OP>
			{
				<sign>.value = -1
			}

<type_definition_part> ::= <TYPE> <type_definition> <type_definition_rest>

<type_definition_rest> ::= <SEMI_COLON> <type_definition_rest_rest>

<type_definition_rest_rest> ::= <type_definition> <type_definition_rest> | <LAMBDA>

<type_definition> ::= <IDENTIFIER> <EQUAL> <type>
						{
                            # incluimos en la tabla de símbolos el tipo, indicando que es un "TIPO" e
                            # incluyendo la estructura que servirá para saber si es un subrango, un array,
                            # o cualquier otro tipo simple
							addNewID(<IDENTIFIER>.lex, newAttr(clase="type", type=<type>.tipo))
						}

<type> ::= <simple_type> 
            {
                <type>.tipo = <simple_type>.tipo
            }
            |
            <structured_type>
            {
                <type>.tipo = <structured_type>.tipo
            }

<simple_type> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> 
					{
						if !<constant>.tipo.instancia(Entero):
							error("Non compatible subrange bounds (int expected, "+<constant>.tipo+" found).")
						else:
							if <NUMBER>.lex <= <constant>.value:
                                # la estructura devuelta por newType contendrá el TIPO,
                                # y las referencias a los valores lowerBound y upperBound
                                lower = newAttr("constant",type = Entero(),value=<NUMBER>.lex) 
                                upper = newAttr("constant",type = Entero(),value=constant.value)
								<simple_type>.tipo = SubEntero(lowerBound=lower, upperBound=upper)
							else:
								error("Invalid subrange: lower bound must be smaller than upper bound.")
					}
					|
					<CHAR> <SUBRANGE_SEPARATOR> <constant> 
					{
						if !<constant>.tipo.instancia(Caracter):
							error("Non compatible subrange bounds (char expected, "+<constant>.tipo+" found).")
						else:
							if <CHAR>.lex <= <constant>.value:
                                # la estructura devuelta por newType contendrá el TIPO,
                                # y las referencias a los valores lowerBound y upperBound
                                lower = newAttr("constant",type = Caracter(),value=<CHAR>.lex)
                                upper = newAttr("constant",type = Caracter(),value=constant.value)
								<simple_type>.tipo = SubCaracter(lowerBound=lower, upperBound=upper)
							else:
								error("Invalid subrange: lower bound must be smaller than upper bound.")
					}
					| 
					<sign> <subrange_type_rest> 
					{
						<subrange_type_rest>.tipo.lowerBound.value = <sign>.value * <subrange_type_rest>.tipo.lowerBound.value
						if <subrange_type_rest>.value.lowerBound.value <= <subrange_type_rest>.tipo.upperBound.value:
							<simple_type>.tipo = <subrange_type_rest>.tipo
						else:
							error("Invalid subrange: lower bound must be smaller than upper bound.")
					}
					| 
					<IDENTIFIER> <simple_type_rest>
					{
						#en este caso hay que pedir el tipo a la tabla de tipos
                        val = getGlobalValue(<IDENTIFIER>.lex)
						if <simple_type_rest>.tipo is not None:
							if val.tipo.instancia(type(simple_type_rest>.value)):
								if val.value <= <simple_type_rest>.value.upperBound.value:
									<simple_type_rest>.value.lowerBound = val
								else:
									error("Invalid subrange: lower bound must be smaller than upper bound.")
							else:
								error("Non compatible subrange bounds ("+ <IDENTIFIER>.tipo +" expected, "+ <simple_type_rest>.value.upperBound.tipo.nombre +" found).")
                        else:
							<simple_type>.tipo = val.tipo
					}

<simple_type_rest> ::= <SUBRANGE_SEPARATOR> <constant> 
						{
                            # la estructura devuelta por newType contendrá el TIPO,
                            # que a su vez contendrá las referencias a los valores lowerBound y upperBound
							if <constant>.tipo.instancia(Entero):
								<simple_type_rest>.value = SubEntero(None,<constant>.value)
							elif <constant>.tipo.instancia(Caracter):
								<simple_type_rest>.value = SubCaracter(None,<constant>.value)
							elif <constant>.tipo.instancia(Booleano):
								<simple_type_rest>.value = SubBooleano(None,<constant>.value)
							else:
								error("Type "+ constant.tipo + "cannot be used in a subrange")
						}
                        |
                        <LAMBDA>
                        {
                            <simple_type_rest>.tipo = None
                        }

<subrange_type_rest> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> 
						{
							if !<constant>.tipo.instancia(Entero):
								error("Non compatible subrange bounds (int expected, "+<constant>.tipo+" found).")
							else:
								if <NUMBER>.lex <= <constant>.value:
									# la estructura devuelta por newType contendrá el TIPO,
									# y las referencias a los valores lowerBound y upperBound
									lower = newAttr("constant",type = Entero(),value=<NUMBER>.lex)
									upper = newAttr("constant",type = Entero(),value=constant.value)
									<subrange_type_rest>.tipo = SubEntero(lowerBound=lower, upperBound=upper)
								else:
									error("Invalid subrange: lower bound must be smaller than upper bound.")
						}
						| 
                        # únicamente se puede llegar a este caso con un signo + o -
                        # así que los identificadores deben ser enteros!
						<IDENTIFIER> <SUBRANGE_SEPARATOR> <constant>
                        {
                            id = getGlobalValue(<IDENTIFIER>.lex)
                            if (id.tipo.instancia(Entero)) and (<constant>.attr.tipo.instancia(Entero)):
                                # la estructura devuelta por newType contendrá el TIPO,
                                # y las referencias a los valores lowerBound y upperBound
                                <subrange_type_rest>.tipo = SubEntero(lowerBound=id, upperBound=<constant>.attr)
                             else:
								 								error("Integer subrange expected")
                        }

						
						#consulta aca... sobre el tipo del índice. Sólo puede ser subrango no?
<structured_type> ::= <ARRAY> <OPEN_BRACKET> <simple_type> <CLOSE_BRACKET> <OF> <simple_type1>
                        {	
							if <simple_type>.tipo.instancia(Simple):
								if <simple_type1>.tipo.instancia(Simple):
								
									<structured_type>.tipo = Arreglo(indexRange=<simple_type>.tipo, elementType = <simple_type1>.tipo)
								else:
									error("The element type must be a simple type")
								<structured_type>.tipo = Arreglo(indexRange=<simple_type>.tipo, elementType = <simple_type1>.tipo)
							else:
								error("The index type must be a simple type")
                        }

<variable_definition_part> ::= <VAR> 
								{
									# globalVarIndex: es el índice actual de la variable, usada en la declaración
									
									<variable_declaration>.tamanioVariables = 0
								}
								<variable_declaration> 
								{
									<variable_declaration_part_rest>.tamanioVariables = <variable_declaration>.tamanioVariables
								}
								<variable_declaration_part_rest>
								{
									<variable_definition_part>.tamanioVariables = <variable_declaration_part_rest>.tamanioVariables
									#libero la memoria con RMEM y el tamaño de las variables
								}

<variable_declaration_part_rest> ::= <SEMI_COLON> 
										{
											<variable_declaration_rest_rest>.tamanioVariables = <variable_declaration_part_rest>.tamanioVariables
										}
										<variable_declaration_rest_rest>
										{
											<variable_declaration_part_rest>.tamanioVariables = <variable_declaration_rest_rest>.tamanioVariables
										}

<variable_declaration_rest_rest> ::={
										<variable_declaration>.tamanioVariables = <variable_declaration_rest_rest>.tamanioVariables
									} 
									<variable_declaration> 
									{
										<variable_declaration_part_rest>.tamanioVariables = <variable_declaration>.tamanioVariables
									} 
									<variable_declaration_part_rest> 	
									{
										<variable_declaration_rest_rest>.tamanioVariables = <variable_declaration_part_rest>.tamanioVariables
									} 
									| 
									<LAMBDA>

<variable_declaration> ::= <IDENTIFIER> 
                            {
								<variable_declaration_rest>.idList = [<IDENTIFIER>.lex] 
							}
                            # en este caso, idList es un atributo heredado Y sintetizado
                            # el valor heredado es "lista vacía", y al volver, contendrá todos los ID después de la , en caso de que haya.
                            <variable_declaration_rest>
                            {
                               
                                for var in <variable_declaration>.idList:
                                    # el valor por defecto de las variables en la tabla de símbolos podría ser None
                                    addNewID(var.lex, newAttr(clase="variable", type=<variable_declaration_rest>.tipo, value=None))
									<variable_declaration>.tamanioVariables += <variable_declaration_rest>.tipo.tamanio
								
                            }

<variable_declaration_rest> ::= <COMMA> <IDENTIFIER> <variable_declaration_rest1>
                                {
                                    <variable_declaration_rest>.idList = <variable_declaration_rest1>.idList.append(<IDENTIFIER>.lex)
                                }
                                |
                                <TYPE_DECLARATION> <type>
                                {
                                    <variable_declaration_rest>.tipo = <type>.tipo
                                }

<procedure_and_function_declaration_part> ::= <procedure_or_function_declaration_part> <SEMI_COLON> <procedure_and_function_declaration_part> 
												| 
												<LAMBDA>

<procedure_or_function_declaration_part> ::= <procedure_declaration> | <function_declaration>

<procedure_declaration> ::= {
								#pongo un label para indicar el principio del procedimiento
							}
							<procedure_heading> 
							{
								#pongo un ENPR con el nivel léxico actual
								<block>.parameterList = <procedure_heading>.parameterList
								<block>.idProc = <procedure_heading>.id
							}
							<block>
							{
								#ponge el retorno de procedimiento, con el nivel léxico actual, y el tamaño que viene en <procedure_heading>.tamanioParams
							}

<procedure_heading> ::= <PROCEDURE> <IDENTIFIER> 
                        {
                            # parameterList es un atributo heredado y sintetizado
                            <procedure_heading_rest>.parameterList = []
							<procedure_heading>.id = <IDENTIFIER>.lex
                        }
                        <procedure_heading_rest>
                        {
                            # <procedure_heading_rest>.parameterList es una lista de listas de parámetros con un tipo asociado, e indicando si es por refer; ejemplo:
                            # para facilidad en la parte de las expresiones, puse que la lista va a tener una serie de tuplas con parametro, tipo y booleano que indica si es por referencia
							# [(p1,int,referencia),(p2,int, referencia)...].
							
                            addNewID(<IDENTIFIER>.lex, newAttr(clase = "procedure", Procedimiento( parameterList = <procedure_heading_rest>.parameterList)))
                            
                        }

<procedure_heading_rest> ::= <SEMI_COLON> 
                            |
                            <OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_rest>
                            {
                                <procedure_heading_rest>.parameterList = <formal_parameter_section>.parameterList + <formal_parameter_rest>.parameterList
                            }

<formal_parameter_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_rest1> 
                            {
                                # el resultado va a ser una lista de listas de parámetros, cada una con un tipo asociado
                                <procedure_heading_rest>.parameterList = <formal_parameter_section>.parameterList + <formal_parameter_rest1>.parameterList
                            }
                            |
                            <CLOSE_PARENTHESIS> <SEMI_COLON>

<formal_parameter_section> ::= <parameter_group> 
                                { 
									<formal_parameter_section>.parameterList=[]
									for x in <parameter_group>.parameterList:
										<formal_parameter_section>.parameterList += (x,<parameter_group>.tipo,False)
                                }
                                |
                                <VAR> <parameter_group>
                                { 
									<formal_parameter_section>.parameterList=[]
									for x in <parameter_group>.parameterList:
										<formal_parameter_section>.parameterList += (x,<parameter_group>.tipo,True)
                                }

<parameter_group> ::=   <IDENTIFIER> 
                        { <parameter_group_rest>.parameterList = [] }
                        <parameter_group_rest>
                        { 
                            <parameter_group>.parameterList = [<IDENTIFIER>.lex] + <parameter_group_rest>.parameterList
                            <parameter_group>.tipo = <parameter_group_rest>.tipo
                        }

<parameter_group_rest> ::= <COMMA> <IDENTIFIER> <parameter_group_rest1> 
                            {
                                <parameter_group_rest>.parameterList = [<IDENTIFIER>.lex] + <parameter_group_rest1>.parameterList
                                <parameter_group_rest>.tipo = <parameter_group_rest1>.tipo
                            }
                            |
                            <TYPE_DECLARATION> <IDENTIFIER>
                            {
                                id = getGlobalValue(<IDENTIFIER>.lex)
                                if id.clase = "type":
                                    <parameter_group_rest>.tipo = id.tipo
                                else:
                                    error("Type expected, but " + <IDENTIFIER>.lex + " found.")
                            }

<function_declaration> ::= {
								#pongo un label para indicar el principio del procedimiento
							}
							<function_heading> 
							{
								<block>.functionID = <function_heading>.functionID #heredo el id de la funcion en bloque para después usarla en el retorno de la funcion
							}
							<block>
							{
								#ponge el retorno de procedimiento, con el nivel léxico actual, y el tamaño que viene en <procedure_heading>.tamanioParams
							}

<function_heading> ::= <FUNCTION> <IDENTIFIER>
						{
                            # parameterList es un atributo heredado y sintetizado
                            <procedure_heading_rest>.parameterList = []
                        }
						<function_heading_rest>
						{
                            # <function_heading_rest>.parameterList es una lista de tuplas de parámetros con un tipo asociado, e indicando si es por refer; ejemplo:
                            # [(p1,int,referencia),(p2,int, referencia)...].
							#<function_heading_rest>.returnType es el tipo que retorna la funcion. Debe ser simple
							if <function_heading_rest>.returnType.instancia(Simple):
								addNewID(<IDENTIFIER>.lex, newAttr(clase = "function", Funcion( parameterList = <procedure_heading_rest>.parameterList,<function_heading_rest>.returnType)))
								<function_heading>.functionID = <IDENTIFIER>.lex
								
							else:	
								error("Functions must return a simple type")
                        }

<function_heading_rest> ::= <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON> 
							{
								id = getGlobalValue(<IDENTIFIER>.lex)
								if id.clase=="type":
									<function_heading_rest>.returnType = id.tipo
								else:
									error("Type expected but " + <IDENTIFIER>.lex + " found")
							}
							|
							<OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_function_rest>
							{
								<function_heading_rest>.parameterList = [(<formal_parameter_section>.parameterList, <formal_parameter_section>.tipo, <formal_parameter_section>.byReference)] + <formal_parameter_function_rest>.parameterList
								<function_heading_rest>.returnType =  <formal_parameter_function_rest>.returnType
							}
							

<formal_parameter_function_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_function_rest> 
									{
										<formal_parameter_function_rest>.parameterList = [(<formal_parameter_section>.parameterList, <formal_parameter_section>.tipo, <formal_parameter_section>.byReference)] + <formal_parameter_function_rest>.parameterList
									}
									| <CLOSE_PARENTHESIS> <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON>
									{
										id = getGlobalValue(<IDENTIFIER>.lex)
										if id.clase=="type":
											<formal_parameter_function_rest>.returnType = id.tipo
										else:
											error("Type expected but " + <IDENTIFIER>.lex + " found")
									}

<statement_part> ::= <compound_statement>

<compound_statement> ::= <BEGIN> <statement> <statement_part_rest> <END>

<statement_part_rest> ::= <SEMI_COLON> <statement> <statement_part_rest> | <LAMBDA>

<statement> ::= <simple_statement> | <structured_statement>

<simple_statement> ::= <IDENTIFIER> 
                        {
                            <simple_statement_rest>.ID = <IDENTIFIER>.lex
						}
                        <simple_statement_rest> 
						| 
						<LAMBDA>

<simple_statement_rest> ::= <ASSIGNMENT> <expression> 
                            {
								# busco primero un retorno de función
                                identifier = getGlobalValue("$" + <simple_statement_rest>.ID)
								if identifier== None:
									identifier = getGlobalValue(<simple_statement_rest>.ID)
                                if identifier.clase == "variable" or identifier== "reference" or identifier=="return":#este control lo hacemos dos veces para poder tirar mejor el error
                                    if checkTypes(identifier.tipo, <expression>.tipo):
                                        if identifier.clase == "variable":
											if identifier.tipo.instancia(Simple):
												#controlo los bounds del tipo, y asigno el valor a la variable
												
											elif identifier.tipo.instancia(Arreglo):
												#asigno todo el arreglo a la variable
											
										elif identifier.clase == "reference":
											if identifier.tipo.instancia(Simple):
												#controlo los bounds del tipo, y asigno el valor a la variable indirecta
												
											elif identifier.tipo.instancia(Arreglo):
												#asigno todo el arreglo a la variable indirecta
											
												
										elif identifier.clase == "return":
											
											#controlo por los bounds, y asigno el valor de la expresión al retorno de función
                                    else:
                                        error("Incompatible types: "+identifier.tipo.nombre+" expected, but "+<expression>.tipo.nombre+" found.")
                            }
                            |
                            <OPEN_BRACKET> <expression> <CLOSE_BRACKET> <ASSIGNMENT> <expression1>
                            {
								array = getGlobalValue(<simple_statement_rest>.ID)
                                if checkTypes(id.tipo.indexType, <expression>.tipo):
									if checkTypes(id.tipo.rangeType, <expression1>.tipo):
										
										# estamos asignando una expresión que estará en la pila a un elemento de un arreglo
										#para esto se le resta el lower bound al índice
										if array.clase == "variable":
											#guardo en el arreglo, en la posición determinada
										elif array.clase == "reference":
											#guardo en el arreglo indirecto, en la posición determinada
									else:
										error("Non compatible types in assignment. %s expected, but %s found" % (id.tipo.indexType, <expression>.tipo))
                                else:                                    
                                    error("Non compatible types in assignment. %s expected as index, but %s found" % (id.tipo.indexType, <expression>.tipo))
                            }
                            |
                            <OPEN_PARENTHESIS> 
							{
								identifier = getGlobalValue(<simple_statement_rest>.ID)
								if identifier.clase== "procedure":
									#armar el nuevo entorno, con su registro de activacion, guardar las variables, y apuntar la ejecucion al codigo del procedimiento
									<actual_parameter>.attr = identifier.tipo.params[0]
									<actual_parameter_rest>.params = identifier.tipo.params[1:]
									nivel = lastLexicalLevel()
									<actual_parameter>.esperado == identifier.tipo.listParams[0]
									<actual_parameter>.id == <simple_statement_rest>.ID
									if nivel == -1:
										<actual_parameter>.id == <simple_statement_rest>.ID
									else:
										<actual_parameter>.id == None
										
								else:
									error(<simple_statement_rest>.ID+ " is not a procedure")
									
							}
							<actual_parameter>
							<actual_parameter_rest> 
							| 
							<LAMBDA>
							{
								identifier = getGlobalValue(<simple_statement_rest>.ID)
								if identifier.clase== "procedure":
									#llamo al procedimiento con label identifier.label
								else:
									error(<simple_statement_rest>.ID+ " is not a procedure")
							}

<expression> ::={
					<simple_expression>.porRef = <expression>.porRef
					<expression_rest>.porRef = <expression>.porRef
				} 
				<simple_expression> 
				{
					<expression_rest>.attr = <simple_expression>.attr
					
					#expression_rest debe heredar el valor de simple_expression
					
				}
				<expression_rest>
				{
					<expression>.attr = <expression_rest>.attr
				}
				

<expression_rest> ::= <relational_operator> <simple_expression> 
					  {
						if <expression_rest>.porRef:
							error("Reference parameter expected")
						if <simple_expression>.attr.tipo.instancia(Simple):
							if checkTypes(<expression_rest>.attr.tipo,<simple_expression>.attr.tipo):
								#se debe apilar el valor de simple_expression, y luego aplicar el operador relacional de relational_operator
								<expression_rest>.attr = Attr(clase="subexpression", tipo = Booleano())
							else:
								error("non compatible types")
						else:
							error("invalid types")
					  }
					  | 
					  <LAMBDA>

<simple_expression> ::= {
							<term>.porRef = <simple_expression>.porRef
						}
						<term> 
						{
							<simple_expression_other>.attr=<term>.attr
							<simple_expression_other>.porRef = <simple_expression>.porRef
						}
						<simple_expression_other> 
						{
							<simple_expression>.attr = <simple_expression_other>.attr
						}

<simple_expression_other> ::= <adding_operator> <term> 
							  {
								if <simple_expression_other>.porRef:
									error("reference parameter expected")
								if <term>.attr.tipo.instancia(<adding_operator>.tipo):
									if checkTypes(<simple_expression_other>.attr.tipo,<term>.attr.tipo):
										# aplicar adding_operator.op
										<simple_expression_other1>.attr = newAttr(tipo=<adding_operator>.tipo,clase="subexpresion")
									else:
								else:
									error("invalid types") 
							  }
							  <simple_expression_other1> 
							  {	
								<simple_expression_other>.attr = <simple_expression_other1>.attr
							  }
							  | 
							  <LAMBDA>

<term> ::= {
			<factor>.porRef = <term>.porRef
			<term_other>.porRef = <term>.porRef
		   }
			<factor>
		   {
			<term_other>.attr = <factor>.attr
		   }
		   <term_other>
		   {
			<term>.attr = <term_other>.attr
		   }

<term_other> ::= <multiplying_operator> <factor>
				 {
					if <term_other>.porRef:
						error("reference parameter expected") 
					if checkTypes(<term_other>.attr.tipo,<factor>.attr.tipo) and <factor>.attr.tipo.instancia(multiplying_operator.tipo):
						# aplicar el operador
						<term_other1>.attr = <factor>.attr
					else:
						error("invalid types")
					<term_other1>.porRef = <term_other>.porRef
				 }
				 <term_other1> 
				 {
					
					<term_other>.attr = <term_other1>.attr
				 }
				 | 
				 <LAMBDA>

<factor> ::= <IDENTIFIER> 
			 {
				<factor_rest>.id=<IDENTIFIER>.lex
				<factor_rest>.porRef=<factor>.porRef
			 }
			 <factor_rest> 
			 {
				<factor>.attr=<factor_rest>.attr
			 }
			 | 
			 <NUMBER> 
			 {
				if <factor>.porRef:
					error("reference parameter expected") 
				<factor>.attr = newAttr(valor=<NUMBER>.lex,tipo=Entero(),clase="subexpression")
				#apilo la constante
			 }
			 | 
			 <OPEN_PARENTHESIS> 
			 {
				<expression>.porRef = <factor>.porRef
			 }
			 <expression> <CLOSE_PARENTHESIS> 
			 {
				if <factor>.porRef:
					error("reference parameter expected") 
				<factor>.attr = <expression>.attr
			 }
			 | 
			 <NOT_LOGOP> <factor1> 
			 {
				if <factor>.porRef:
					error("reference parameter expected") 
				if <factor1>.attr.tipo.instancia(Booleano):
					<factor>.attr = newAttr(tipo=Booleano(),clase="subexpresion")
					#aplicar la negación lógica
				else:
					error("Boolean expected but "+<factor1>.tipo+" found")
			 }
			 | 
			 <CHAR>
			 {
				if <factor>.porRef:
					error("reference parameter expected") 
				
				<factor>.attr = newAttr(valor=<CHAR>.lex,tipo=Caracter(),clase="literal")
				#apilo la constante char
			 }
			 |
			 <sign> <factor1>
			 {
				if <factor>.porRef:
					error("reference parameter expected") 
				if <factor1>.attr.tipo.instancia(Entero):
					<factor>.attr = newAttr(tipo=Entero(),clase="subexpresion")
					if <sign>.value==-1:
						# UMEN
				else:
					error("Integer expected but  "+<factor1>.tipo+" found")
			 }
			 # modifique esto de la gramatica y simple_expression porque sino habia que heredar el signo y era un quilombo

<factor_rest> ::= <OPEN_BRACKET> <expression> <CLOSE_BRACKET> 
				  {
					array = getGlobalValue(<factor_rest>.id)
					nivel = lastLexicalLevel()
					if array.tipo.instancia(Arreglo):
						if checkTypes(<expression>.attr.tipo,array.tipo.index):
							#chequear que el resultado de la expresion este dentro del rango, sino tirar index out of bounds
							#restar el lower bound del arreglo
							<factor_rest>.attr = newAttr(tipo=array.tipo.element,clase="subexpresion")
							if <factor_rest>.porRef:
								#apilo el valor indirecto 
							else:
								#apilo el valor
						else:
							error(array.tipo + " expected as index but " + <expression>.attr.tipo + " found")
					else:
						error(<factor_rest>.id + " is not a valid array")
						
				  }
				  | 
				  <OPEN_PARENTHESIS> 
				  {
					if <factor_rest>.porRef:
						error("reference parameter expected") 
					fun = getGlobalValue(<factor_rest>.id)
					if fun.clase=="function":
						if len(fun.tipo.listParams)>0:
							if lastLexicalLevel()==-1:
								#la función es predefinida, por lo que a partir del identificador, se invoca a un macro que ejecute la función
							else:
								#reservar espacio para el valor de retorno
								<actual_parameter>.esperado = fun.tipo.listParams[0]
								<actual_parameter_rest>.listParams = listParams[1:]
						else:
							error("More parameters than expected")
					else:
						error(<factor_rest>.id + " is not a function")
				  } 
				  <actual_parameter>
				  <actual_parameter_rest> 
				  {
					# llamar a la funcion con los parametros que estaran debidamente apilados
					<factor_rest>.attr=newAttr(tipo=id.tipo.ret,clase="subexpresion")
				  }
				  | 
				  <LAMBDA>
				  {
					id = getGlobalValue(<factor_rest>.id)
					if id.clase=="function":
						if <factor_rest>.porRef:
							error("reference parameter expected") 
						#llamar a la funcion sin parametros
						<factor_rest>.attr = newAttr(tipo=id.tipo.ret,clase="subexpresion")
					elif id.clase=="variable":
						if <factor_rest>.porRef:
							#apilar la dirección de memoria de la variable
						else:
							if id.tipo.instancia(Simple): #es una variable o una constante.
								# se coloca el valor del id en la pila
							elif id.tipo.instancia(Arreglo):
								# se coloca el arreglo entero en la pila
						<factor_rest>.attr = deepcopy(id)
					elif id.clase=="constant": 
						if <factor_rest>.porRef:
							error("reference parameter expected") 
						# se apila el valor de la constante
						<factor_rest>.attr = deepcopy(id)
					elif id.clase=="reference":
						if porRef:
							# apilar la direccion de la variable
						else:
							if identifier.tipo.instancia(Simple):
								# apilo un valor de una variable con una inderección
							elif identifier.tipo.instancia(Arreglo):
								# apilo todo un arreglo con una indirección
						attr.ref = deepcopy(identifier)
					else:
						error("Function, variable or constant expected, but "+id.tipo+" found")
					
				  }

<actual_parameter> ::= {
						<expression>.porRef=<actual_parameter>.expected[2]#aca viene el booleano de si es por referencia o on
						
					   }
					   <expression>
					   {
						if <actual_parameter>.id!= None: # si es True, es una función predefinida
							# se escribe la macro para imprimir, que depende de la instrucción, y del tipo del parámetro
						else:
							if not checkTypes(<expression>.attr.tipo,<actual_parameter>.esperado[1]):
								error("another type expected")
					   }

<actual_parameter_rest> ::= <COMMA> 
							{
								if len(<actual_parameter_rest>.parameterList)>0:
									<actual_parameter>.expected = <actual_parameter_rest>.parameterList[0][1:2]
								else:
									error("More parameters than expected")
							}
							<actual_parameter>
							{
								#colocar el parametro en la pila
								<actual_parameter_rest>.parameterList=parameterList[1:]
							}
							<actual_parameter_rest> 
							| 
							<CLOSE_PARENTHESIS>
							{
								if len(<actual_parameter_rest>.parameterList)>0:
									error("Less parameters than expected")
							}

<multiplying_operator> ::= <MULTIPLY_OP> 
							{
								<multiplying_operator>.op = "MULT"
								<multiplying_operator>.tipo = Entero()
							
							}
							| 
							<DIV_OP> 
							{
								<multiplying_operator>.op = "DIVI"
								<multiplying_operator>.tipo = Entero()
							}
							| 
							<AND_LOGOP>
							{
								<multiplying_operator>.op = "DISJ"
								<multiplying_operator>.tipo = Booleano()
							}

<adding_operator> ::= <ADD_OP> 
						{
							<multiplying_operator>.op = "SUMA"
							<multiplying_operator>.tipo = Entero()
						
						}
						|
						<MINUS_OP> 
						{
							<multiplying_operator>.op = "SUST"
							<multiplying_operator>.tipo = Entero()
						
						}
						|
						<OR_LOGOP>
						{
							<multiplying_operator>.op = "CONJ"
							<multiplying_operator>.tipo = Booleano()
						
						}

<relational_operator> ::= <LESS_OP> 
							{
								<multiplying_operator>.op = "CMME"
								<multiplying_operator>.tipo = Simple()
							
							}
							| 
							<LESS_EQUAL_OP> 	
							{
								<multiplying_operator>.op = "CMNI"
								<multiplying_operator>.tipo = Simple()
							
							}
							| 
							<GREATER_OP> 
							{
								<multiplying_operator>.op = "CMMA"
								<multiplying_operator>.tipo = Simple()
							
							}
							| 
							<GREATER_EQUAL_OP> 
							{
								<multiplying_operator>.op = "CMYI"
								<multiplying_operator>.tipo = Simple()
							
							}
							| 
							<NOT_EQUAL_OP> 
							{
								<multiplying_operator>.op = "CMDG"
								<multiplying_operator>.tipo = Tipo() #no estoy seguro si se pueden comparar tipos estructurados tmb ...
							}
							| 
							<EQUAL>
							{
								<multiplying_operator>.op = "CMIG"
								<multiplying_operator>.tipo = Tipo()#no estoy seguro si se pueden comparar tipos estructurados tmb ...
							
							}

<structured_statement> ::= <compound_statement> | <conditional_statement> | <repetitive_statement>

<conditional_statement> ::= <IF> <expression> 
							{
								if <expression>.tipo.instancia(Booleano):
									#apilar su valor en la lista..
									#aplicar desvio si falso a la etiqueta de despues del if
									<conditional_statement_other>.label = #label de después del if
								else:
									error("Boolean expected")
							}
							<THEN> <statement> <conditional_statement_other>

<conditional_statement_other> ::= <ELSE>
								  {
									#desvio si verdadero a la etiqueta de despues del if
								  } 
								  <statement> 
								  | 
								  {
									#pongo etiqueta de después del if
								  }
								  <LAMBDA>

<repetitive_statement> ::= <WHILE> 
							{
								#poner un label de inicio de expresion
							}
							<expression> 
							{
								if <expression>.tipo.instancia(Booleano):
									#apilar su valor en la lista..
									#aplicar desvio si falso a la etiqueta de despues del while
								else:
									error("Boolean expected")
							}
							<DO> <statement> 
							{
								#desvío siempre al comienzo de la expresión
								#label de fin de while
							}

\end{lstlisting}

\chapter{Analizador Semántico}

Una vez especificado el Esquema de Traducción, se procedió a implementar la última etapa del compilador; se detallarán a continuación las secciones más reelevantes del desarrollo.

\section{Tablas de Símbolos}
La primera clase agregada por el analizador semántico es la Tabla de símbolos, cuyo código puede ser encontrado en el archivo \texttt{hashStack.py}. Como el nombre del archivo indica, la implementación consiste de una {\bf pila de tablas de símbolos}; la pila se encuentra implementada utilizando una lista de Python (que por defecto posee las operaciones características de las pilas, como \texttt{Push()} y \texttt{Pop()}); cada una de las tablas de símbolos está implementada con diccionarios de Python, que son tablas hash optimizadas y cuentan con la ventaja de que tanto la inserción como la búsqueda en la tabla es de orden constante.

Inicialmente, la pila contiene una tabla de símbolos con todos los identificadores predefinidos mostrados en el cuadro \ref{tab:predefinidos}.

\begin{table}[htbp]
\centering
\begin{tabular}{|l| p{13cm}|}
\hline
\textbf{Identificador}			& \textbf{Contenido} \\ \hline
true	& {\ttfamily Attr(valor = 1, tipo = Booleano(), clase = "`constant"')} \\ \hline
false							& {\ttfamily Attr(valor = 0, tipo = Booleano(), clase = "`constant"')} \\ \hline
integer								& {\ttfamily  Attr(tipo = Entero(), clase = "`type"')} \\ \hline
boolean						& {\ttfamily Attr (tipo = Booleano(), clase = "`type"')}  \\ \hline 
char					& {\ttfamily Attr(tipo = Caracter(), clase = "`type"')} \\ \hline
write	& {\ttfamily Attr(tipo = Procedimiento(params = [("`x"',Simple(),False)]), clase = "`procedure"')} \\ \hline
writeln			& {\ttfamily Attr(tipo = Procedimiento(params = [("`x"',Simple(),False)]), clase = "`procedure"')} \\ \hline
read			& {\ttfamily Attr(tipo = Procedimiento(params = [("`x"',Simple(),True)]), clase = "`procedure"')} \\ \hline
readln		 					& {\ttfamily Attr(tipo = Procedimiento(params = [("`x"',Simple(),True)]), clase = "`procedure"')}\\ \hline
maxint 					& {\ttfamily Attr(tipo = Entero(), clase = "`constant"', valor = 32767)}\\ \hline
ord				& {\ttfamily Attr(tipo = Funcion(params = [("`x"',Caracter(),False)], ret = Entero()), clase = "`function"')}\\ \hline
chr							& {\ttfamily Attr(tipo = Funcion(params = [("`x"',Entero(),False)], ret = Caracter()), clase = "function")}\\\hline
pred 					& {\ttfamily Attr(tipo = Funcion(params = [("x",Simple(),False)], ret = Simple()), clase = "function")} \\ \hline
succ 					& {\ttfamily Attr(tipo = Funcion(params = [("x",Simple(),False)], ret = Simple()), clase = "function")} \\ \hline
\end{tabular}

\caption{Identificadores predefinidos}
\label{tab:predefinidos}
\end{table}
Por cada nivel léxico analizado se apila una nueva tabla de símbolos, que es utilizada durante todo el bloque y desapilada una vez que dicho nivel léxico termina de ser analizado.

Las búsquedas de identificadores se realizan desde la última tabla de símbolos apilada hacia las anteriores, recorriendo todos los niveles léxicos alcanzables desde donde se solicitó el identificador. Si éste no se encuentra una vez que se recorrieron todas las tablas, se arroja la excepción \texttt{SymbolTableError} indicando que el identificador no está declarado.

Cuando se declara un nuevo identificador, éste se inserta automáticamente en la tabla de símbolos del nivel léxico actual; si bien no importa lo que se haya declarado en los niveles léxicos superiores, sí se arroja una excepción en caso de que el identificador ya exista en el nivel actual.

\subsection{Contenido}
Las tablas de símbolos de todos los niveles están compuestas por un identificador y un objeto de tipo \texttt{Attr} que contiene todos los atributos que se consideró necesario guardar del identificador.

La clase \texttt{Attr} está compuesta de cinco atributos:

\begin{itemize}
 \item {\bf Clase}: define si el identificador corresponde a un \emph{program}, \emph{type}, \emph{variable}, \emph{function}, \emph{procedure} o \emph{constant}.
 \item {\bf Pos}: indica el número de identificador en el programa, función o procedimiento actual. Es utilizado junto con otros valores para la reserva y la referencia de memoria.
 \item {\bf Valor}: retiene el valor de las constantes, variables y caracteres.
 \item {\bf Tipo}: contiene el tipo específico del identificador, apuntando a un objeto de la jerarquía de tipos que se detallará en la sección siguiente. Referenciando a este objeto se puede obtener, además, mucha información específica del identificador.
 \item {\bf Used}: valor booleano que indica si el identificador fue utilizado en el bloque en el que fue declarado o no. Es utilizado para mostrar \textit{warnings} en caso de que sea falso.
\end{itemize}

\subsection{Tipos}

Como se mencionó, cada uno de los identificadores en la tabla de símbolos posee un tipo determinado dentro de la jerarquía de tipos. Dicha jerarquía se encuentra graficada en la figura \ref{jerarquia}, y la implementación de cada uno de los tipos que la componen se encuentra en el archivo \texttt{tipos.py}.

\begin{figure}[htbc]

\centering
\includegraphics[width=150mm]{jerarquia.png}

\caption{Jeraqu\'{i}a de tipos}
\label{jerarquia}
\end{figure}

\section{Implementación del EDT}
La implementación del Esquema de Traducción en Python fue realizada adaptando todas las acciones indicadas en el EdT a instrucciones propias del lenguaje.

Los atributos heredados en el esquema se implementaron mediante parámetros pasados por valor; en cuanto a los atributos sintetizados, dado que Python no posee parámetros por referencia (que hubiese sido el salto a implementación ideal), se utilizó un nivel de indirección extra: se envía una referencia a un objeto que simboliza el atributo sintetizado.

De esta manera, el procedimiento en el nivel ``inferior'' modifica el contenido del objeto, y una vez que finaliza, el procedimiento de nivel ``superior'' puede acceder a los atributos del objeto modificados, lo que coincide con la semántica de los atributos sintetizados en una gramática.

\section{Errores detectados}

El analizador semántico detecta una gran cantidad de errores en el código fuente de los programas; en caso de encontrar alguno, se arroja la excepción \texttt{SemanticError} y se aborta inmediatamente la compilación; las situaciones de error pueden clasificarse a grandes rasgos en:

\begin{itemize}
 \item {\bf Tipos incompatibles}: se indica cuando se intenta realizar una operación con dos elementos de tipos que no pueden interactuar entre sí; por ejemplo, asignar un caracter a una variable de tipo entero, sumar dos valores booleanos, u operar con dos arreglos de diferente tamaño o tipo de componente.
 \item {\bf Out of bounds}: ocurre cuando no se respetan los valores máximos o mínimos de un tipo; por ejemplo, si se quisiera asignar una constante entera 99999999999999999999.
 \item {\bf Rangos inválidos}: cuando un subrango declarado no cumple alguna de las especificaciones definidas; por ejemplo, declarar un subrango cuyo valor inferior es mayor al valor superior, o declarar valores límite con diferentes tipos.
 \item {\bf Clases inesperadas}: ocurre cuando se lee un identificador válido, pero la clase de éste no es la que el compilador espera; por ejemplo, si en una declaración de variables se lee el tipo de una variable, pero dicho tipo resulta ser un identificador de procedimiento.
 \item {\bf Invocación errónea}: ocurre cuando se realiza una llamada a una función o procedimiento, pero la cantidad o el tipo de los parámetros no coincide con los declarados.
\end{itemize} 


\begin{thebibliography}{9}
\addcontentsline{toc}{chapter}{Bibliografía}
\bibitem{aho}
  Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman
  \emph{Compilers: principles, techniques, and tools}.
  Addison Wesley
  2nd Edition
  2007.
  
\bibitem{enunciado}
	Cátedra de Compiladores e Intérpretes, DCIC, UNS
	\emph{Proyecto Nº1: Compilador de Mini-Pascal-S}
	2010
	
\bibitem{consideraciones}
	Cátedra de Compiladores e Intérpretes, DCIC, UNS
	\emph{Consideraciones Generales para la entrega final del Proyecto Nº1 - Compilador + MEPa}
	2010

\end{thebibliography}

\end{document}