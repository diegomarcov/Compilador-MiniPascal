<program> ::= 	{
					stStack = newSymbolTableStack()
                    // falta pushear un nuevo nivel de la tabla, agregar todos los id predefinidos,
                    // y ver qué hacer con el identificador del programa
				} 
				<program_heading> 
				<block>
                {
                    addNewID(program_heading.title, Program())
                }
				<END_PROGRAM> <EOF>

<program_heading> ::= <PROGRAM> <IDENTIFIER>
						{
							<program_heading>.title = <IDENTIFIER>.lex
						}
					<SEMI_COLON>

<block> ::= { stStack.pushNewSymbolTable() }
            <constant_definition_part> <block_cons_rest> 
            | 
            { stStack.pushNewSymbolTable() }
            <block_cons_rest>

<block_cons_rest> ::= <type_definition_part> <block_type_rest> | <block_type_rest>

<block_type_rest> ::= <variable_definition_part> <block_var_rest> | <block_var_rest>

<block_var_rest> ::= <procedure_and_function_declaration_part> <statement_part> | <statement_part>

<constant_definition_part> ::= <CONST> <constant_definition> <constant_definition_rest>

<constant_definition_rest> ::= <SEMI_COLON> <constant_definition_rest_rest>

<constant_definition_rest_rest> ::= <constant_definition> <constant_definition_rest> | <LAMBDA>

<constant_definition> ::= <IDENTIFIER> <EQUAL> <constant> 
							{
                                // addNewID deberá tener un identificador, y un objeto;
                                // dicho objeto tendrá las propiedades: TIPO, VALOR, y un valor booleano que indica si es constante
								addNewID(<IDENTIFIER>.lex, <constant>.attr)
							}

<constant> ::= 	<NUMBER>
				{
                    <constant>.attr = newAttr(clase="constant", type=Entero(), value=<NUMBER>.lex)
				}
				|
				<IDENTIFIER>
				{
					val = getGlobalValue(<IDENTIFIER>.lex)
					if ((val != None)):
						if (val.clase=="constant"):
							<constant>.attr = copy(val) //copio el attr
						else:
							if (val.clase=="variable"):
								if val.tipo.instancia(Simple):
									<constant>.attr = Attr(clase="constant",type = val.tipo, value=val.value)
								else:
									error(<IDENTIFIER>.lex + "must be of a simple type") //no se si está bien dicho eso
							else:
								error(<IDENTIFIER>.lex + "is not a valid identifier")
					else:
						error("Undeclared identifier " + <IDENTIFIER>.lex)
				}
				| 
				<CHAR> 
				{
                    <constant>.attr = newAttr(clase="constant", type=Char(), value=<CHAR>.lex)
				}
				| <sign> <constant_rest>
				{
					if !<constant_rest>.tipo.instancia(Entero):
						error("Can not apply "+<sign>.lex+" operator to "+<constant_rest>.tipo) //como redefino __str__ de todos los tipos puedo hacer cosas como esa
					else:
                        <constant_rest>.attr.value = <sign>.value * <constant_rest>.attr.value
                        <constant>.attr = <constant_rest>.attr
						
				}
				

<constant_rest> ::= <NUMBER> 
					{
						<constant_rest>.attr = newAttr(clase="constant", type=Entero(), value=<NUMBER>.lex)
					}
					|
					<IDENTIFIER>
					{
						val = getGlobalValue(<IDENTIFIER>.lex)
						if ((val != None)):
							if (val.clase=="constant"):
								<constant>.attr = copy(val) //copio el attr
							else:
								if (val.clase=="variable"):
									<constant>.attr = Attr(clase="constant",type = val.tipo, value=val.value)
								else:
									error(<IDENTIFIER>.lex + "is not a valid identifier")
						else:
							error("Undeclared identifier " + <IDENTIFIER>.lex)
					}

<sign> ::= <ADD_OP>
			{
				<sign>.value = 1
			}
			|
			<MINUS_OP>
			{
				<sign>.value = -1
			}

<type_definition_part> ::= <TYPE> <type_definition> <type_definition_rest>

<type_definition_rest> ::= <SEMI_COLON> <type_definition_rest_rest>

<type_definition_rest_rest> ::= <type_definition> <type_definition_rest> | <LAMBDA>

<type_definition> ::= <IDENTIFIER> <EQUAL> <type>
						{
                            // incluimos en la tabla de símbolos el tipo, indicando que es un "TIPO" e
                            // incluyendo la estructura que servirá para saber si es un subrango, un array,
                            // o cualquier otro tipo simple
							addNewID(<IDENTIFIER>.lex, newAttr(clase="type", type=<type>.tipo))
						}

<type> ::= <simple_type> 
            {
                <type>.tipo = <simple_type>.tipo
            }
            |
            <structured_type>
            {
                <type>.tipo = <structured_type>.tipo
            }

<simple_type> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> 
					{
						if <constant>.tipo.nombre != "int":
							error("Non compatible subrange bounds (int expected, "+<constant>.tipo+" found).")
						else:
							if <NUMBER>.lex <= <constant>.value:
                                // la estructura devuelta por newType contendrá el TIPO,
                                // y las referencias a los valores lowerBound y upperBound
                                lower = newAttr("constant",type = Entero(),value=<NUMBER>.lex) //no se si tiene sentido mandar attrs, porque ya sabemos que son del mismo tipo... estamos haciendo los controles antes de agregarlos
                                upper = newAttr("constant",type = Entero(),value=constant.value)
								<simple_type>.tipo = SubEntero(lowerBound=lower, upperBound=upper)
							else:
								error("Invalid subrange: lower bound must be smaller than upper bound.")

					|
					<CHAR> <SUBRANGE_SEPARATOR> <constant> 
					{
						if <constant>.tipo.nombre != "char":
							error("Non compatible subrange bounds (char expected, "+<constant>.tipo+" found).")
						else:
							if <CHAR>.lex <= <constant>.value:
                                // la estructura devuelta por newType contendrá el TIPO,
                                // y las referencias a los valores lowerBound y upperBound
                                lower = newAttr("constant",type = Caracter(),value=<CHAR>.lex)
                                upper = newAttr("constant",type = Caracter(),value=constant.value)
								<simple_type>.tipo = SubCaracter(lowerBound=lower, upperBound=upper)
							else:
								error("Invalid subrange: lower bound must be smaller than upper bound.")
					}
					| 
					<sign> <subrange_type_rest> 
					{
						<subrange_type_rest>.tipo.lowerBound.value = <sign>.value * <subrange_type_rest>.tipo.lowerBound.value
						if <subrange_type_rest>.value.lowerBound.value <= <subrange_type_rest>.tipo.upperBound.value:
							<simple_type>.tipo = <subrange_type_rest>.tipo
						else:
							error("Invalid subrange: lower bound must be smaller than upper bound.")
					}
					| 
					<IDENTIFIER> <simple_type_rest>
					{
						//en este caso hay que pedir el tipo a la tabla de tipos
                        val = getGlobalValue(<IDENTIFIER>.lex)
						if <simple_type_rest>.tipo is not None:
							if <simple_type_rest>.tipo.instancia(Subrango):
								if val.tipo.nombre == <simple_type_rest>.value.nombre:
									if val.value <= <simple_type_rest>.value.upperBound.value:
										<simple_type_rest>.value.lowerBound = val
									else:
										error("Invalid subrange: lower bound must be smaller than upper bound.")
								else:
									error("Non compatible subrange bounds ("+ <IDENTIFIER>.tipo +" expected, "+ <simple_type_rest>.value.upperBound.tipo.nombre +" found).")
							else:
								//esto no puede pasar
								pass
                        else:
							<simple_type>.tipo = val.tipo
					}

<simple_type_rest> ::= <SUBRANGE_SEPARATOR> <constant> 
						{
                            // la estructura devuelta por newType contendrá el TIPO,
                            // que a su vez contendrá las referencias a los valores lowerBound y upperBound
                            <simple_type_rest>.tipo = newType("subrange", lowerBound=None, upperBound=<constant>.attr)
						}
                        |
                        <LAMBDA>
                        {
                            <simple_type_rest>.tipo = None
                        }

<subrange_type_rest> ::= <NUMBER> <SUBRANGE_SEPARATOR> <constant> 
						{
							if <constant>.attr.tipo.nombre != "int":
								error("Non compatible subrange bounds (int expected, "+<constant>.tipo+" found).")
							else:
                                // la estructura devuelta por newType contendrá el TIPO,
                                // y las referencias a los valores lowerBound y upperBound
								<subrange_type_rest>.tipo = newType("subrange", lowerBound=<NUMBER>.lex, upperBound=<constant>.attr)
						}
						| 
                        // únicamente se puede llegar a este caso con un signo + o -
                        // así que los identificadores deben ser enteros!
						<IDENTIFIER> <SUBRANGE_SEPARATOR> <constant>
                        {
                            id = getGlobalValue(<IDENTIFIER>.lex)
                            if (id.tipo.nombre == "int") and (<constant>.attr.tipo.nombre == "int"):
                                // la estructura devuelta por newType contendrá el TIPO,
                                // y las referencias a los valores lowerBound y upperBound
                                <subrange_type_rest>.tipo = newType("subrange", lowerBound=id, upperBound=<constant>.attr)
                        }

<structured_type> ::= <ARRAY> <OPEN_BRACKET> <simple_type> <CLOSE_BRACKET> <OF> <simple_type1>
                        { // dado este caso, si simple_type NO es un subrango, entonces debe ser un TIPO;
                          // de cualquier manera, alcanza con indicar que dicho tipo definirá el rango de valores
                          // que pueden ser índice en el array
                            <structured_type>.tipo = newType("array", indexRange=<simple_type>.tipo, elementType = <simple_type1>.tipo)
                        }

<variable_definition_part> ::= <VAR> <variable_declaration> <variable_declaration_part_rest>

<variable_declaration_part_rest> ::= <SEMI_COLON> <variable_declaration_rest_rest>

<variable_declaration_rest_rest> ::= <variable_declaration> <variable_declaration_part_rest> | <LAMBDA>

<variable_declaration> ::= <IDENTIFIER> 
                            { <variable_declaration_rest>.idList = [] }
                            // en este caso, idList es un atributo heredado Y sintetizado
                            // el valor heredado es "lista vacía", y al volver, contendrá todos los ID después de la , en caso de que haya.
                            <variable_declaration_rest>
                            {
                                <variable_declaration>.idList = <variable_declaration_rest>.idList.append(<IDENTIFIER>.lex)
                                for var in <variable_declaration>.idList:
                                    // el valor por defecto de las variables en la tabla de símbolos podría ser None
                                    addNewID(var.lex, newAttr(clase="variable", type=<variable_declaration_rest>.tipo, value=None))
                            }

<variable_declaration_rest> ::= <COMMA> <IDENTIFIER> <variable_declaration_rest1>
                                {
                                    <variable_declaration_rest>.idList = <variable_declaration_rest1>.idList.append(<IDENTIFIER>.lex)
                                }
                                |
                                <TYPE_DECLARATION> <type>
                                {
                                    <variable_declaration_rest>.tipo = <type>.tipo
                                }

<procedure_and_function_declaration_part> ::= <procedure_or_function_declaration_part> <SEMI_COLON> <procedure_and_function_declaration_part> | <LAMBDA>

<procedure_or_function_declaration_part> ::= <procedure_declaration> | <function_declaration>

<procedure_declaration> ::= <procedure_heading> <block>

<procedure_heading> ::= <PROCEDURE> <IDENTIFIER> 
                        {
                            // parameterList es un atributo heredado y sintetizado
                            <procedure_heading_rest>.parameterList = []
                        }
                        <procedure_heading_rest>
                        {
                            // <procedure_heading_rest>.parameterList es una lista de listas de parámetros con un tipo asociado, e indicando si es por refer; ejemplo:
                            // [ ([p1, p2, p3], int, referencia), ([p4, p5], char, valor) ]
                            addNewID(<IDENTIFIER>.lex, newAttr(clase = "procedure", type=newType("procedure", parameterList = <procedure_heading_rest>.parameterList)))
                            // nótese que éste ID se agrega en la tabla de nivel "superior", porque se apila una nueva tabla al comenzar
                            // a parsear <block>
                        }

<procedure_heading_rest> ::= <SEMI_COLON> 
                            |
                            <OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_rest>
                            {
                                <procedure_heading_rest>.procedureParameterList = [(<formal_parameter_section>.parameterList, <formal_parameter_section>, <formal_parameter_section>.byReference)] + <formal_parameter_rest>.parameterList
                            }

<formal_parameter_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_rest1> 
                            {
                                // el resultado va a ser una lista de listas de parámetros, cada una con un tipo asociado
                                <procedure_heading_rest>.parameterList = [(<formal_parameter_section>.parameterList, <formal_parameter_section>.tipo, <formal_parameter_section>.byReference)] + <formal_parameter_rest1>.parameterList
                            }
                            |
                            <CLOSE_PARENTHESIS> <SEMI_COLON>

<formal_parameter_section> ::= <parameter_group> 
                                { 
                                    <formal_parameter_section>.parameterList = <parameter_group>.parameterList
                                    <formal_parameter_section>.tipo = <parameter_group>.tipo
                                    <formal_parameter_section>.byReference = False
                                }
                                |
                                <VAR> <parameter_group>
                                { 
                                    <formal_parameter_section>.parameterList = <parameter_group>.parameterList
                                    <formal_parameter_section>.tipo = <parameter_group>.tipo
                                    <formal_parameter_section>.byReference = True
                                }

<parameter_group> ::=   <IDENTIFIER> 
                        { <parameter_group_rest>.parameterList = [] }
                        <parameter_group_rest>
                        { 
                            <parameter_group>.parameterList = [<IDENTIFIER>.lex] + <parameter_group_rest>.parameterList
                            <parameter_group>.tipo = <parameter_group_rest>.tipo
                        }

<parameter_group_rest> ::= <COMMA> <IDENTIFIER> <parameter_group_rest1> 
                            {
                                <parameter_group_rest>.parameterList = [<IDENTIFIER>.lex] + <parameter_group_rest1>.parameterList
                                <parameter_group_rest>.tipo = <parameter_group_rest1>.tipo
                            }
                            |
                            <TYPE_DECLARATION> <IDENTIFIER>
                            {
                                id = getGlobalValue(<IDENTIFIER>.lex)
                                if id.clase = "type":
                                    <parameter_group_rest>.tipo = id.tipo
                                else:
                                    error("Type expected, but " + <IDENTIFIER>.lex + " found.")
                            }

<function_declaration> ::= <function_heading> <block>

<function_heading> ::= <FUNCTION> <IDENTIFIER> <function_heading_rest>

<function_heading_rest> ::= <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON> | <OPEN_PARENTHESIS> <formal_parameter_section> <formal_parameter_function_rest>

<formal_parameter_function_rest> ::= <SEMI_COLON> <formal_parameter_section> <formal_parameter_function_rest> | <CLOSE_PARENTHESIS> <TYPE_DECLARATION> <IDENTIFIER> <SEMI_COLON>

<statement_part> ::= <compound_statement>

<compound_statement> ::= <BEGIN> <statement> <statement_part_rest> <END>

<statement_part_rest> ::= <SEMI_COLON> <statement> <statement_part_rest> | <LAMBDA>

<statement> ::= <simple_statement> | <structured_statement>

<simple_statement> ::= <IDENTIFIER> 
                        {
                            simple_statement_rest.ID = <IDENTIFIER>.lex
                        }
                        <simple_statement_rest> | <LAMBDA>

<simple_statement_rest> ::= <ASSIGNMENT> <expression> 
                            {
                                identifier = getGlobalValue(<simple_statement_rest>.ID)
                                if identifier.clase == "variable":
                                    if checkTypes(identifier.tipo, <expression>.tipo):
                                        // se asigna el valor de la expresión a la variable
                                    else:
                                        error("Incompatible types: "+identifier.tipo.nombre+" expected, but "+<expression>.tipo.nombre+" found.")
                                else:
                                    error("Left side of assignment must be a variable!")
                            }
                            |
                            <OPEN_BRACKET> <expression> <CLOSE_BRACKET> <ASSIGNMENT> <expression1>
                            {
                                if checkTypes(id.tipo, newType("array", indexRange=<expression>.tipo, elementType=<expression1>.tipo)):
                                    // estamos asignando una expresión a un elemento de un arreglo
                                else:
                                    // habría que controlar este mensaje de error: puede ser un problema del índice, o de la expresión que asignamos
                                    error("Non compatible types in assignment: "
                            }
                            |
                            <OPEN_PARENTHESIS> <actual_parameter> <actual_parameter_rest> | <LAMBDA>

<component_variable> ::= <IDENTIFIER> <OPEN_BRACKET> <expression> <CLOSE_BRACKET>

<expression> ::= <simple_expression> <expression_rest>

<expression_rest> ::= <relational_operator> <simple_expression> | <LAMBDA>

<simple_expression> ::= <term> <simple_expression_other> | <sign> <term> <simple_expression_other>

<simple_expression_other> ::= <adding_operator> <term> <simple_expression_other> | <LAMBDA>

<term> ::= <factor> <term_other>

<term_other> ::= <multiplying_operator> <factor> <term_other> | <LAMBDA>

<factor> ::= <IDENTIFIER> <factor_rest> | <NUMBER> | <OPEN_PARENTHESIS> <expression> <CLOSE_PARENTHESIS> | <NOT_LOGOP> <factor> | <CHAR>

<factor_rest> ::= <OPEN_BRACKET> <expression> <CLOSE_BRACKET> | <OPEN_PARENTHESIS> <actual_parameter> <actual_parameter_rest> | <LAMBDA>

<actual_parameter> ::= <expression>

<actual_parameter_rest> ::= <COMMA> <actual_parameter> <actual_parameter_rest> | <CLOSE_PARENTHESIS>

<multiplying_operator> ::= <MULTIPLY_OP> | <DIV_OP> | <AND_LOGOP>

<adding_operator> ::= <ADD_OP> | <MINUS_OP> | <OR_LOGOP>

<relational_operator> ::= <LESS_OP> | <LESS_EQUAL_OP> | <GREATER_OP> | <GREATER_EQUAL_OP> | <NOT_EQUAL_OP> | <EQUAL>

<procedure_statement> ::= <IDENTIFIER> <procedure_statement_rest>

<procedure_statement_rest> ::= <OPEN_PARENTHESIS> <actual_parameter> <actual_parameter_rest> | <LAMBDA>

<structured_statement> ::= <compound_statement> | <conditional_statement> | <repetitive_statement>

<conditional_statement> ::= <IF> <expression> <THEN> <statement> <conditional_statement_other>

<conditional_statement_other> ::= <ELSE> <statement> | <LAMBDA>

<repetitive_statement> ::= <WHILE> <expression> <DO> <repetitive_statement_rest>

<repetitive_statement_rest> ::= <statement> | <LAMBDA>